	<h1>Gauge Variant Error Metrics</h1>
	<p>This tab provides a variety of common (and uncommon) error metrics derived from the estimated gate set.  All of these quanties are <q>gauge-dependent</q>, which means two things.  First, they aren't directly physically measurable, so they can't map directly to observable error rates.  Second, they are only as reliable (as diagnostics) inasmuch as pyGSTi is able to pick a sensible gauge (reference frame) in which to report gates.  PyGSTi does this by first finding an estimate based on the data (and ignoring gauge entirely), then varying over all possible representations of those gates (gauges) to minimize a measure of the gates' implausibility (distance from the targets, combined with violation of positivity).  This measure has parameters -- e.g. the weights placed on different gates -- and reports often include multiple "gauge optimizations".  A dropdown menu in the sidebar allows switching between these options, and the parameters used for the currently-shown estimate are shown below it.</p>

	<!-- Moved to GaugeInvariant tab for now, since only predicted RB error rate -->
	<!-- <figure id="bestGatesetVsTargetTable" class='tbl'>
	  <figcaption><span class="captiontitle">Overall error metrics</span> <span class="captiondetail">This table presents metrics that quantify the distance between the ideal target gateset and the estimated gateset, and which quantify the <em>aggregated</em> distance between <i>entire gate sets</i>.</span></figcaption>
	  (bestGatesetVsTargetTable)s
	</figure> -->

	<figure id="bestGatesetSpamVsTargetTable" class='tbl'>
	  <figcaption><span class="captiontitle">SPAM error metrics</span> <span class="captiondetail"> This table presents (gauge-variant) metrics that quantify errors in the <em>SPAM operations</em> -- the estimated initial state preparation[s] and POVM measurement -- with respect to the ideal target operations,   A description of each metric can be found by hovering the pointer over the column header.</span></figcaption>
	  <script>
  $(document).ready(function() {
var switchmap_table_4750 = new Array();
switchmap_table_4750[ [0,1,0] ] = 'table_4750_1';
switchmap_table_4750[ [0,0,0] ] = 'table_4750_0';
window.switchmap_table_4750 = switchmap_table_4750;

function connect_table_4750_to_switches(){
  if($('#switchbd1410_0').hasClass('initializedSwitch') && $('#switchbd1410_1').hasClass('initializedSwitch') && $('#switchbd1410_2').hasClass('initializedSwitch')) {
    $('#switchbd1410_0').on('selectmenuchange', function() {table_4750_onchange(); });
    $('#switchbd1410_1').on('selectmenuchange', function() {table_4750_onchange(); });
    $('#switchbd1410_2').on('change', function() {table_4750_onchange(); });
    $( '#table_4750' ).closest('.tabcontent').on('tabchange', function(){
table_4750_onchange(); });
    table_4750_onchange();
    console.log('Switches initialized: table_4750 handlers set');
    $( '#table_4750' ).show()
  }
  else {
    setTimeout(connect_table_4750_to_switches, 500);
    console.log('table_4750 switches NOT initialized: Waiting...');
  }
};
$(document).ready(function() {
  connect_table_4750_to_switches();
});

function table_4750_onchange() {
  var tabdiv = $( '#table_4750' ).closest('.tabcontent');
  if( tabdiv.length > 0 && !tabdiv.hasClass('active') ) return;
  var curSwitchPos = new Array();
  curSwitchPos.push($('#switchbd1410_0').val());
  curSwitchPos.push($('#switchbd1410_1').val());
  curSwitchPos.push($("#switchbd1410_2 > input[name='switchbd1410_2']:checked").val());
  var idToShow = switchmap_table_4750[ curSwitchPos ];
  $( '#table_4750' ).children().hide();
  divToShow = $( '#' + idToShow );
  if( divToShow.children().length == 0 ) {
    loadLocal('figures/' + idToShow + '.html', '#' + idToShow, function() {
        divToShow = $( '#' + idToShow );
        divToShow.show();
        divToShow.parentsUntil('#table_4750').show();
        caption = divToShow.closest('figure').children('figcaption:first');
        caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
    });
  }
  else {
    divToShow.show();
    divToShow.parentsUntil('#table_4750').show();
    caption = divToShow.closest('figure').children('figcaption:first');
    caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
  }
}
}); //end on-ready handler

</script>

<div id='table_4750' class='pygsti-wsoutput-group'>
<div class='single_switched_value' id='table_4750_0'></div>

<div class='single_switched_value' id='table_4750_1'></div>

</div>

	</figure>
	
	<figure id="bestGatesVsTargetTable_gv" class='tbl'>
	  <figcaption><span class="captiontitle">Individual gate error metrics</span> <span class="captiondetail">This table presents various (gauge-variant) metrics that quantify errors in each individual estimated logic gate, with respect to the ideal target gates.  Note that "Entanglement infidelity" and "Average gate infidelity" are two common definitions of process fidelity, and related by a constant dimensional factor.  A description of each metric can be found by  hovering the pointer over the column header.</span></figcaption>
	  <script>
  $(document).ready(function() {
var switchmap_table_766 = new Array();
switchmap_table_766[ [0,1,0] ] = 'table_766_1';
switchmap_table_766[ [0,0,0] ] = 'table_766_0';
window.switchmap_table_766 = switchmap_table_766;

function connect_table_766_to_switches(){
  if($('#switchbd1410_0').hasClass('initializedSwitch') && $('#switchbd1410_1').hasClass('initializedSwitch') && $('#switchbd1410_2').hasClass('initializedSwitch')) {
    $('#switchbd1410_0').on('selectmenuchange', function() {table_766_onchange(); });
    $('#switchbd1410_1').on('selectmenuchange', function() {table_766_onchange(); });
    $('#switchbd1410_2').on('change', function() {table_766_onchange(); });
    $( '#table_766' ).closest('.tabcontent').on('tabchange', function(){
table_766_onchange(); });
    table_766_onchange();
    console.log('Switches initialized: table_766 handlers set');
    $( '#table_766' ).show()
  }
  else {
    setTimeout(connect_table_766_to_switches, 500);
    console.log('table_766 switches NOT initialized: Waiting...');
  }
};
$(document).ready(function() {
  connect_table_766_to_switches();
});

function table_766_onchange() {
  var tabdiv = $( '#table_766' ).closest('.tabcontent');
  if( tabdiv.length > 0 && !tabdiv.hasClass('active') ) return;
  var curSwitchPos = new Array();
  curSwitchPos.push($('#switchbd1410_0').val());
  curSwitchPos.push($('#switchbd1410_1').val());
  curSwitchPos.push($("#switchbd1410_2 > input[name='switchbd1410_2']:checked").val());
  var idToShow = switchmap_table_766[ curSwitchPos ];
  $( '#table_766' ).children().hide();
  divToShow = $( '#' + idToShow );
  if( divToShow.children().length == 0 ) {
    loadLocal('figures/' + idToShow + '.html', '#' + idToShow, function() {
        divToShow = $( '#' + idToShow );
        divToShow.show();
        divToShow.parentsUntil('#table_766').show();
        caption = divToShow.closest('figure').children('figcaption:first');
        caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
    });
  }
  else {
    divToShow.show();
    divToShow.parentsUntil('#table_766').show();
    caption = divToShow.closest('figure').children('figcaption:first');
    caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
  }
}
}); //end on-ready handler

</script>

<div id='table_766' class='pygsti-wsoutput-group'>
<div class='single_switched_value' id='table_766_0'></div>

<div class='single_switched_value' id='table_766_1'></div>

</div>

	</figure>

	<figure id="singleMetricTable_gv" class='tbl'>
	  <figcaption><span class="captiontitle">Single metric comparison.</span> <span class="captiondetail">TODO: caption</span> </figcaption>
	  <script>
$(document).ready(function() {
  $('#switchbd6079_0').selectmenu();$('#switchbd6079_0').addClass('initializedSwitch');

});
</script>

<div class='switch_container'><fieldset>
<label for='switchbd6079_0'>Metric</label>
<select name='switchbd6079_0' id='switchbd6079_0'>
<option value=0 selected='selected'>Entanglement Infidelity</option>
<option value=1>Avg. Gate Infidelity</option>
<option value=2>1/2 Trace Distance</option>
<option value=3>1/2 Diamond-Dist</option>
<option value=4>Non-unitary Ent. Infidelity</option>
<option value=5>Non-unitary Avg. Gate Infidelity</option>
<option value=6>Frobenius Distance</option>
</select>
</fieldset></div>

	  <script>
  $(document).ready(function() {
var switchmap_table_6302 = new Array();
switchmap_table_6302[ [1,0] ] = 'table_6302_1';
switchmap_table_6302[ [5,0] ] = 'table_6302_5';
switchmap_table_6302[ [0,0] ] = 'table_6302_0';
switchmap_table_6302[ [4,0] ] = 'table_6302_4';
switchmap_table_6302[ [2,0] ] = 'table_6302_2';
switchmap_table_6302[ [3,0] ] = 'table_6302_3';
switchmap_table_6302[ [6,0] ] = 'table_6302_6';
window.switchmap_table_6302 = switchmap_table_6302;

function connect_table_6302_to_switches(){
  if($('#switchbd6079_0').hasClass('initializedSwitch') && $('#switchbd1410_2').hasClass('initializedSwitch')) {
    $('#switchbd6079_0').on('selectmenuchange', function() {table_6302_onchange(); });
    $('#switchbd1410_2').on('change', function() {table_6302_onchange(); });
    $( '#table_6302' ).closest('.tabcontent').on('tabchange', function(){
table_6302_onchange(); });
    table_6302_onchange();
    console.log('Switches initialized: table_6302 handlers set');
    $( '#table_6302' ).show()
  }
  else {
    setTimeout(connect_table_6302_to_switches, 500);
    console.log('table_6302 switches NOT initialized: Waiting...');
  }
};
$(document).ready(function() {
  connect_table_6302_to_switches();
});

function table_6302_onchange() {
  var tabdiv = $( '#table_6302' ).closest('.tabcontent');
  if( tabdiv.length > 0 && !tabdiv.hasClass('active') ) return;
  var curSwitchPos = new Array();
  curSwitchPos.push($('#switchbd6079_0').val());
  curSwitchPos.push($("#switchbd1410_2 > input[name='switchbd1410_2']:checked").val());
  var idToShow = switchmap_table_6302[ curSwitchPos ];
  $( '#table_6302' ).children().hide();
  divToShow = $( '#' + idToShow );
  if( divToShow.children().length == 0 ) {
    loadLocal('figures/' + idToShow + '.html', '#' + idToShow, function() {
        divToShow = $( '#' + idToShow );
        divToShow.show();
        divToShow.parentsUntil('#table_6302').show();
        caption = divToShow.closest('figure').children('figcaption:first');
        caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
    });
  }
  else {
    divToShow.show();
    divToShow.parentsUntil('#table_6302').show();
    caption = divToShow.closest('figure').children('figcaption:first');
    caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
  }
}
}); //end on-ready handler

</script>

<div id='table_6302' class='pygsti-wsoutput-group'>
<div class='single_switched_value' id='table_6302_0'></div>

<div class='single_switched_value' id='table_6302_1'></div>

<div class='single_switched_value' id='table_6302_2'></div>

<div class='single_switched_value' id='table_6302_3'></div>

<div class='single_switched_value' id='table_6302_4'></div>

<div class='single_switched_value' id='table_6302_5'></div>

<div class='single_switched_value' id='table_6302_6'></div>

</div>

	</figure>


	<!-- <figure id="bestGatesetEigenvalueTable" class='tbl'>
	  <figcaption><span class="captiontitle">Relative Eigenvalues of estimated gates.</span> <span class="captiondetail"> This table shows the spectrum of the matrix obtained by dividing each estimated gate by its ideal (target) counterpart.  The second column displays these eigenvalues over the complex disc.</span></figcaption>
	  (bestGatesetRelEvalTable)s
	</figure> -->

	<figure id="bestGatesVsTargetTable_gvgerms" class='tbl'>
	  <figcaption><span class="captiontitle">Per-germ error metrics</span> <span class="captiondetail">This table presents various (gauge-variant) metrics that quantify errors in the estimated <em>germs</em>, with respect to their ideal target counterparts (as computed from the ideal target gates).  A description of each metric can be found by  hovering the pointer over the column header..</span></figcaption>
	  <script>
  $(document).ready(function() {
var switchmap_table_9675 = new Array();
switchmap_table_9675[ [0,1,0] ] = 'table_9675_1';
switchmap_table_9675[ [0,0,0] ] = 'table_9675_0';
window.switchmap_table_9675 = switchmap_table_9675;

function connect_table_9675_to_switches(){
  if($('#switchbd1410_0').hasClass('initializedSwitch') && $('#switchbd1410_1').hasClass('initializedSwitch') && $('#switchbd1410_2').hasClass('initializedSwitch')) {
    $('#switchbd1410_0').on('selectmenuchange', function() {table_9675_onchange(); });
    $('#switchbd1410_1').on('selectmenuchange', function() {table_9675_onchange(); });
    $('#switchbd1410_2').on('change', function() {table_9675_onchange(); });
    $( '#table_9675' ).closest('.tabcontent').on('tabchange', function(){
table_9675_onchange(); });
    table_9675_onchange();
    console.log('Switches initialized: table_9675 handlers set');
    $( '#table_9675' ).show()
  }
  else {
    setTimeout(connect_table_9675_to_switches, 500);
    console.log('table_9675 switches NOT initialized: Waiting...');
  }
};
$(document).ready(function() {
  connect_table_9675_to_switches();
});

function table_9675_onchange() {
  var tabdiv = $( '#table_9675' ).closest('.tabcontent');
  if( tabdiv.length > 0 && !tabdiv.hasClass('active') ) return;
  var curSwitchPos = new Array();
  curSwitchPos.push($('#switchbd1410_0').val());
  curSwitchPos.push($('#switchbd1410_1').val());
  curSwitchPos.push($("#switchbd1410_2 > input[name='switchbd1410_2']:checked").val());
  var idToShow = switchmap_table_9675[ curSwitchPos ];
  $( '#table_9675' ).children().hide();
  divToShow = $( '#' + idToShow );
  if( divToShow.children().length == 0 ) {
    loadLocal('figures/' + idToShow + '.html', '#' + idToShow, function() {
        divToShow = $( '#' + idToShow );
        divToShow.show();
        divToShow.parentsUntil('#table_9675').show();
        caption = divToShow.closest('figure').children('figcaption:first');
        caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
    });
  }
  else {
    divToShow.show();
    divToShow.parentsUntil('#table_9675').show();
    caption = divToShow.closest('figure').children('figcaption:first');
    caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
  }
}
}); //end on-ready handler

</script>

<div id='table_9675' class='pygsti-wsoutput-group'>
<div class='single_switched_value' id='table_9675_0'></div>

<div class='single_switched_value' id='table_9675_1'></div>

</div>

	</figure>

	

		
	
