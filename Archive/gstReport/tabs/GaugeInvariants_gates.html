	<h1>Gauge Invariant Error Metrics</h1>
	<p>GST can estimate gates <em>up to an overall gauge</em>.  PyGSTi tries to find a good gauge in which to report process matrices and gauge-variant metrics like fidelity -- but sometimes this goes wrong.  The most reliable error metrics and gate properties are <em>gauge-invariant</em> ones, and these are listed on this tab.</p>

	<figure id="bestGatesetVsTargetTable" class='tbl'>
	  <figcaption><span class="captiontitle">RB error metrics</span> <span class="captiondetail">This table shows estimates for the error rate that would be obtained using two different Randomized Benchmarking (RB) protocols . The Clifford RB number corresponds to the most standard form of RB, Clifford RB (CRB), where random Clifford gate sequences are performed. This number is dependent on how the Clifford operations are compiled into the primitive gates, and so if you didn't specify a Clifford compilation and pygsti couldn't deduce one, this quantity will be absent. Note that this is the error rate per-Clifford; it has not been rescaled to a per-primitive error rate. The primitive RB number corresponds to performing RB on random sequences of the primitive gates, rather than the Cliffords, which is known as <q>Direct RB</q> (DRB). DRB allows for sampling layers of primitives according to a general probability distribution over the primitive gates; the number reported here corresponds to uniformly sampling the primitive gates. This number does not require any compilation table and is always be computed by pyGSTi. Two caveats regarding these RB numbers: 1) The primitive RB number is not meaningful for arbitrary gate sets; if the gate set generates the Clifford group or it is a universal gate set then it is definitely meaningful, modulo the second caveat. 2) These predicted RB numbers rely on a perturbative technique, and if the estimated gates are far from their ideal counterparts the predicted numbers may be very inaccurate (and the empirical RB error rate itself may even be ill-defined: the RB decay could be non-exponential). For both of these RB protocols there is also more than one definition of the RB number, as a function of the p obtained from fitting RB data to <span class="math">A + Bp^m</span>. Here we use the definition <span class="math">r = (4^n - 1)(1-p)/4^n</span> for an n-qubit gate set, which means that <span class="math">r</span> = entanglement infidelity = 1/2 diamond distance if there are uniform depolarizing errors on all the gates (where these two quantities are w.r.t. the gate set benchmarked, so the Clifford gates for CRB and the primitive gates for DRB). For more general errors, these first two quantities will often be roughly equal, although that is not guaranteed. Note that these numbers should not be directly compared to RB numbers derived using the commonly-used alternative formula <span class="math">r = (2^n - 1)(1-p)/2^n</span> (which is related to average gate infidelity, rather than entanglement infidelity).</span></figcaption>
	  <script>
  $(document).ready(function() {
var switchmap_table_2097 = new Array();
switchmap_table_2097[ [0,1,0] ] = 'table_2097_1';
switchmap_table_2097[ [0,0,0] ] = 'table_2097_0';
window.switchmap_table_2097 = switchmap_table_2097;

function connect_table_2097_to_switches(){
  if($('#switchbd1410_0').hasClass('initializedSwitch') && $('#switchbd1410_1').hasClass('initializedSwitch') && $('#switchbd1410_2').hasClass('initializedSwitch')) {
    $('#switchbd1410_0').on('selectmenuchange', function() {table_2097_onchange(); });
    $('#switchbd1410_1').on('selectmenuchange', function() {table_2097_onchange(); });
    $('#switchbd1410_2').on('change', function() {table_2097_onchange(); });
    $( '#table_2097' ).closest('.tabcontent').on('tabchange', function(){
table_2097_onchange(); });
    table_2097_onchange();
    console.log('Switches initialized: table_2097 handlers set');
    $( '#table_2097' ).show()
  }
  else {
    setTimeout(connect_table_2097_to_switches, 500);
    console.log('table_2097 switches NOT initialized: Waiting...');
  }
};
$(document).ready(function() {
  connect_table_2097_to_switches();
});

function table_2097_onchange() {
  var tabdiv = $( '#table_2097' ).closest('.tabcontent');
  if( tabdiv.length > 0 && !tabdiv.hasClass('active') ) return;
  var curSwitchPos = new Array();
  curSwitchPos.push($('#switchbd1410_0').val());
  curSwitchPos.push($('#switchbd1410_1').val());
  curSwitchPos.push($("#switchbd1410_2 > input[name='switchbd1410_2']:checked").val());
  var idToShow = switchmap_table_2097[ curSwitchPos ];
  $( '#table_2097' ).children().hide();
  divToShow = $( '#' + idToShow );
  if( divToShow.children().length == 0 ) {
    loadLocal('figures/' + idToShow + '.html', '#' + idToShow, function() {
        divToShow = $( '#' + idToShow );
        divToShow.show();
        divToShow.parentsUntil('#table_2097').show();
        caption = divToShow.closest('figure').children('figcaption:first');
        caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
    });
  }
  else {
    divToShow.show();
    divToShow.parentsUntil('#table_2097').show();
    caption = divToShow.closest('figure').children('figcaption:first');
    caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
  }
}
}); //end on-ready handler

</script>

<div id='table_2097' class='pygsti-wsoutput-group'>
<div class='single_switched_value' id='table_2097_0'></div>

<div class='single_switched_value' id='table_2097_1'></div>

</div>

	</figure>
	
	<figure id="bestGatesetSpamParametersTable" class='tbl'>
	  <figcaption><span class="captiontitle">SPAM probabilities</span> <span class="captiondetail"> This table shows estimated SPAM probabilities for each measurement outcome.  These are computed as <span class="math">\mathrm{Tr}[\rho E_i]</span>, where <span class="math">\rho</span> is an estimated initial state (often labelled <span class="math">\rho_0</span>), and <span class="math">\{E_i\}</span> is the estimated <em>n</em>-outcome POVM.  The symbol <span class="math">E_C</span> denotes the <em>n</em>th POVM effect, which is not allowed to vary freely but is defined by subtracting the sum of the other effects (which <em>are</em> freely varied) from the identity.</span></figcaption>
	  <script>
  $(document).ready(function() {
var switchmap_table_5933 = new Array();
switchmap_table_5933[ [0,1,0] ] = 'table_5933_1';
switchmap_table_5933[ [0,0,0] ] = 'table_5933_0';
window.switchmap_table_5933 = switchmap_table_5933;

function connect_table_5933_to_switches(){
  if($('#switchbd1410_0').hasClass('initializedSwitch') && $('#switchbd1410_1').hasClass('initializedSwitch') && $('#switchbd1410_2').hasClass('initializedSwitch')) {
    $('#switchbd1410_0').on('selectmenuchange', function() {table_5933_onchange(); });
    $('#switchbd1410_1').on('selectmenuchange', function() {table_5933_onchange(); });
    $('#switchbd1410_2').on('change', function() {table_5933_onchange(); });
    $( '#table_5933' ).closest('.tabcontent').on('tabchange', function(){
table_5933_onchange(); });
    table_5933_onchange();
    console.log('Switches initialized: table_5933 handlers set');
    $( '#table_5933' ).show()
  }
  else {
    setTimeout(connect_table_5933_to_switches, 500);
    console.log('table_5933 switches NOT initialized: Waiting...');
  }
};
$(document).ready(function() {
  connect_table_5933_to_switches();
});

function table_5933_onchange() {
  var tabdiv = $( '#table_5933' ).closest('.tabcontent');
  if( tabdiv.length > 0 && !tabdiv.hasClass('active') ) return;
  var curSwitchPos = new Array();
  curSwitchPos.push($('#switchbd1410_0').val());
  curSwitchPos.push($('#switchbd1410_1').val());
  curSwitchPos.push($("#switchbd1410_2 > input[name='switchbd1410_2']:checked").val());
  var idToShow = switchmap_table_5933[ curSwitchPos ];
  $( '#table_5933' ).children().hide();
  divToShow = $( '#' + idToShow );
  if( divToShow.children().length == 0 ) {
    loadLocal('figures/' + idToShow + '.html', '#' + idToShow, function() {
        divToShow = $( '#' + idToShow );
        divToShow.show();
        divToShow.parentsUntil('#table_5933').show();
        caption = divToShow.closest('figure').children('figcaption:first');
        caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
    });
  }
  else {
    divToShow.show();
    divToShow.parentsUntil('#table_5933').show();
    caption = divToShow.closest('figure').children('figcaption:first');
    caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
  }
}
}); //end on-ready handler

</script>

<div id='table_5933' class='pygsti-wsoutput-group'>
<div class='single_switched_value' id='table_5933_0'></div>

<div class='single_switched_value' id='table_5933_1'></div>

</div>

	</figure>


	<figure id="gramBarPlot" class='tbl'>
	  <figcaption><span class="captiontitle">Gram matrix spectrum.</span> <span class="captiondetail">The GST Gram matrix is not a standard error metric, but it is gauge-invariant and critical to the GST process.  It provides some insight into generalized SPAM.  It is the (estimated) matrix of inner products between all the input states prepared by the various preparation fiducials, and all the measured effects prepared by the various measurement fiducials.  LGST involves inverting the Gram matrix, so it needs to be full rank.  In the plot, each pair of bars shows the <em>n</em>th  eigenvalues of the estimated Gram matrix and the Gram matrix predicted by the ideal targets (respectively).  Larger eigenvalues indicate better sensitivity, and the number of non-zero values indicates the dimension of the state (density matrix) space being probed (e.g., for a single qubit, the Gram matrix should have 4 O(1) eigenvalues).</span> </figcaption>
	  <script>
  $(document).ready(function() {
var switchmap_plot_4313 = new Array();
switchmap_plot_4313[ [0,1] ] = 'plot_4313_1';
switchmap_plot_4313[ [0,0] ] = 'plot_4313_0';
window.switchmap_plot_4313 = switchmap_plot_4313;

function connect_plot_4313_to_switches(){
  if($('#switchbd1410_0').hasClass('initializedSwitch') && $('#switchbd1410_1').hasClass('initializedSwitch')) {
    $('#switchbd1410_0').on('selectmenuchange', function() {plot_4313_onchange(); });
    $('#switchbd1410_1').on('selectmenuchange', function() {plot_4313_onchange(); });
    $( '#plot_4313' ).closest('.tabcontent').on('tabchange', function(){
plot_4313_onchange(); });
    plot_4313_onchange();
    console.log('Switches initialized: plot_4313 handlers set');
    $( '#plot_4313' ).show()
  }
  else {
    setTimeout(connect_plot_4313_to_switches, 500);
    console.log('plot_4313 switches NOT initialized: Waiting...');
  }
};
$(document).ready(function() {
  connect_plot_4313_to_switches();
});

function plot_4313_onchange() {
  var tabdiv = $( '#plot_4313' ).closest('.tabcontent');
  if( tabdiv.length > 0 && !tabdiv.hasClass('active') ) return;
  var curSwitchPos = new Array();
  curSwitchPos.push($('#switchbd1410_0').val());
  curSwitchPos.push($('#switchbd1410_1').val());
  var idToShow = switchmap_plot_4313[ curSwitchPos ];
  $( '#plot_4313' ).children().hide();
  divToShow = $( '#' + idToShow );
  if( divToShow.children().length == 0 ) {
    loadLocal('figures/' + idToShow + '.html', '#' + idToShow, function() {
        divToShow = $( '#' + idToShow );
        divToShow.show();
        divToShow.parentsUntil('#plot_4313').show();
        caption = divToShow.closest('figure').children('figcaption:first');
        caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
    });
  }
  else {
    divToShow.show();
    divToShow.parentsUntil('#plot_4313').show();
    caption = divToShow.closest('figure').children('figcaption:first');
    caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
  }
}
make_wsplot_resizable("plot_4313");
}); //end on-ready handler

</script>

<div id='plot_4313' class='pygsti-wsoutput-group'>
<div class='single_switched_value relwrap' id='plot_4313_0'></div>

<div class='single_switched_value relwrap' id='plot_4313_1'></div>

</div>

	</figure>

	<figure id="bestGatesVsTargetTable_gi" class='tbl'>
	  <figcaption><span class="captiontitle">Spectral error metrics between estimated gates and ideal targets</span> <span class="captiondetail">This table presents a variety of gauge-invariant quantities that quantify the distance or discrepancy between (1) an estimated gate, and (2) the ideal corresponding target operation.  Each of these error metrics depends <em>only</em> on a specific gate's spectrum (eigenvalues), which are gauge-invariant and non-relational (i.e., they pertain to a single gate).  Hovering over a column header will pop up a mathematical description of the corresponding metric.</span></figcaption>
	  <script>
  $(document).ready(function() {
var switchmap_table_7889 = new Array();
switchmap_table_7889[ [0,1] ] = 'table_7889_1';
switchmap_table_7889[ [0,0] ] = 'table_7889_0';
window.switchmap_table_7889 = switchmap_table_7889;

function connect_table_7889_to_switches(){
  if($('#switchbd1410_0').hasClass('initializedSwitch') && $('#switchbd1410_1').hasClass('initializedSwitch')) {
    $('#switchbd1410_0').on('selectmenuchange', function() {table_7889_onchange(); });
    $('#switchbd1410_1').on('selectmenuchange', function() {table_7889_onchange(); });
    $( '#table_7889' ).closest('.tabcontent').on('tabchange', function(){
table_7889_onchange(); });
    table_7889_onchange();
    console.log('Switches initialized: table_7889 handlers set');
    $( '#table_7889' ).show()
  }
  else {
    setTimeout(connect_table_7889_to_switches, 500);
    console.log('table_7889 switches NOT initialized: Waiting...');
  }
};
$(document).ready(function() {
  connect_table_7889_to_switches();
});

function table_7889_onchange() {
  var tabdiv = $( '#table_7889' ).closest('.tabcontent');
  if( tabdiv.length > 0 && !tabdiv.hasClass('active') ) return;
  var curSwitchPos = new Array();
  curSwitchPos.push($('#switchbd1410_0').val());
  curSwitchPos.push($('#switchbd1410_1').val());
  var idToShow = switchmap_table_7889[ curSwitchPos ];
  $( '#table_7889' ).children().hide();
  divToShow = $( '#' + idToShow );
  if( divToShow.children().length == 0 ) {
    loadLocal('figures/' + idToShow + '.html', '#' + idToShow, function() {
        divToShow = $( '#' + idToShow );
        divToShow.show();
        divToShow.parentsUntil('#table_7889').show();
        caption = divToShow.closest('figure').children('figcaption:first');
        caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
    });
  }
  else {
    divToShow.show();
    divToShow.parentsUntil('#table_7889').show();
    caption = divToShow.closest('figure').children('figcaption:first');
    caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
  }
}
}); //end on-ready handler

</script>

<div id='table_7889' class='pygsti-wsoutput-group'>
<div class='single_switched_value' id='table_7889_0'></div>

<div class='single_switched_value' id='table_7889_1'></div>

</div>

	</figure>

	<figure id="singleMetricTable_gi" class='tbl'>
	  <figcaption><span class="captiontitle">Single metric comparison.</span> <span class="captiondetail">TODO: caption</span> </figcaption>
	  <script>
$(document).ready(function() {
  $('#switchbd3683_0').selectmenu();$('#switchbd3683_0').addClass('initializedSwitch');

});
</script>

<div class='switch_container'><fieldset>
<label for='switchbd3683_0'>Metric</label>
<select name='switchbd3683_0' id='switchbd3683_0'>
<option value=0 selected='selected'>Eigenvalue Ent. Infidelity</option>
<option value=1>Eigenvalue Avg. Gate Infidelity</option>
<option value=2>Eigenvalue Non-U. Ent. Infidelity</option>
<option value=3>Eigenvalue Non-U. Avg. Gate Infidelity</option>
<option value=4>Eigenvalue 1/2 Diamond-Dist</option>
<option value=5>Eigenvalue Non-U. 1/2 Diamond-Dist</option>
</select>
</fieldset></div>

	  <script>
  $(document).ready(function() {
var switchmap_table_6969 = new Array();
switchmap_table_6969[ [1,0] ] = 'table_6969_1';
switchmap_table_6969[ [5,0] ] = 'table_6969_5';
switchmap_table_6969[ [0,0] ] = 'table_6969_0';
switchmap_table_6969[ [4,0] ] = 'table_6969_4';
switchmap_table_6969[ [2,0] ] = 'table_6969_2';
switchmap_table_6969[ [3,0] ] = 'table_6969_3';
window.switchmap_table_6969 = switchmap_table_6969;

function connect_table_6969_to_switches(){
  if($('#switchbd3683_0').hasClass('initializedSwitch') && $('#switchbd1410_2').hasClass('initializedSwitch')) {
    $('#switchbd3683_0').on('selectmenuchange', function() {table_6969_onchange(); });
    $('#switchbd1410_2').on('change', function() {table_6969_onchange(); });
    $( '#table_6969' ).closest('.tabcontent').on('tabchange', function(){
table_6969_onchange(); });
    table_6969_onchange();
    console.log('Switches initialized: table_6969 handlers set');
    $( '#table_6969' ).show()
  }
  else {
    setTimeout(connect_table_6969_to_switches, 500);
    console.log('table_6969 switches NOT initialized: Waiting...');
  }
};
$(document).ready(function() {
  connect_table_6969_to_switches();
});

function table_6969_onchange() {
  var tabdiv = $( '#table_6969' ).closest('.tabcontent');
  if( tabdiv.length > 0 && !tabdiv.hasClass('active') ) return;
  var curSwitchPos = new Array();
  curSwitchPos.push($('#switchbd3683_0').val());
  curSwitchPos.push($("#switchbd1410_2 > input[name='switchbd1410_2']:checked").val());
  var idToShow = switchmap_table_6969[ curSwitchPos ];
  $( '#table_6969' ).children().hide();
  divToShow = $( '#' + idToShow );
  if( divToShow.children().length == 0 ) {
    loadLocal('figures/' + idToShow + '.html', '#' + idToShow, function() {
        divToShow = $( '#' + idToShow );
        divToShow.show();
        divToShow.parentsUntil('#table_6969').show();
        caption = divToShow.closest('figure').children('figcaption:first');
        caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
    });
  }
  else {
    divToShow.show();
    divToShow.parentsUntil('#table_6969').show();
    caption = divToShow.closest('figure').children('figcaption:first');
    caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
  }
}
}); //end on-ready handler

</script>

<div id='table_6969' class='pygsti-wsoutput-group'>
<div class='single_switched_value' id='table_6969_0'></div>

<div class='single_switched_value' id='table_6969_1'></div>

<div class='single_switched_value' id='table_6969_2'></div>

<div class='single_switched_value' id='table_6969_3'></div>

<div class='single_switched_value' id='table_6969_4'></div>

<div class='single_switched_value' id='table_6969_5'></div>

</div>

	</figure>


	<figure id="bestGatesetEigenvalueTable" class='tbl'>
	  <figcaption><span class="captiontitle">Eigenvalues of estimated gates.</span> <span class="captiondetail"> This table lists the spectrum of each estimated gate.  It also breaks out the real and imaginary parts of each eigenvalue, <em>and</em> it compares the estimated eigenvalues to those of the ideal target gates in several useful ways.  To do these comparisons, each estimated eigenvalue needs to be matched up with a target eigenvalue, and pyGSTi does this independently for each metric by computing a minimum-weight matching based on that metric.  Hovering over a column header will pop up a mathematical description of the corresponding metric.</span></figcaption>
	  <script>
  $(document).ready(function() {
var switchmap_table_2133 = new Array();
switchmap_table_2133[ [0,1] ] = 'table_2133_1';
switchmap_table_2133[ [0,0] ] = 'table_2133_0';
window.switchmap_table_2133 = switchmap_table_2133;

function connect_table_2133_to_switches(){
  if($('#switchbd1410_0').hasClass('initializedSwitch') && $('#switchbd1410_1').hasClass('initializedSwitch')) {
    $('#switchbd1410_0').on('selectmenuchange', function() {table_2133_onchange(); });
    $('#switchbd1410_1').on('selectmenuchange', function() {table_2133_onchange(); });
    $( '#table_2133' ).closest('.tabcontent').on('tabchange', function(){
table_2133_onchange(); });
    table_2133_onchange();
    console.log('Switches initialized: table_2133 handlers set');
    $( '#table_2133' ).show()
  }
  else {
    setTimeout(connect_table_2133_to_switches, 500);
    console.log('table_2133 switches NOT initialized: Waiting...');
  }
};
$(document).ready(function() {
  connect_table_2133_to_switches();
});

function table_2133_onchange() {
  var tabdiv = $( '#table_2133' ).closest('.tabcontent');
  if( tabdiv.length > 0 && !tabdiv.hasClass('active') ) return;
  var curSwitchPos = new Array();
  curSwitchPos.push($('#switchbd1410_0').val());
  curSwitchPos.push($('#switchbd1410_1').val());
  var idToShow = switchmap_table_2133[ curSwitchPos ];
  $( '#table_2133' ).children().hide();
  divToShow = $( '#' + idToShow );
  if( divToShow.children().length == 0 ) {
    loadLocal('figures/' + idToShow + '.html', '#' + idToShow, function() {
        divToShow = $( '#' + idToShow );
        divToShow.show();
        divToShow.parentsUntil('#table_2133').show();
        caption = divToShow.closest('figure').children('figcaption:first');
        caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
    });
  }
  else {
    divToShow.show();
    divToShow.parentsUntil('#table_2133').show();
    caption = divToShow.closest('figure').children('figcaption:first');
    caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
  }
}
}); //end on-ready handler

</script>

<div id='table_2133' class='pygsti-wsoutput-group'>
<div class='single_switched_value' id='table_2133_0'></div>

<div class='single_switched_value' id='table_2133_1'></div>

</div>

	</figure>
