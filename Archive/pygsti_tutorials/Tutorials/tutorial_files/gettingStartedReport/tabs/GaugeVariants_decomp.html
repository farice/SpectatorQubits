        <h1>Gate Decompositions</h1>
	<p>This tab presents several <q>decompositions</q> of the process matrices shown on the <q>Raw Estimates</q> tab.  These are derived properties of the process matrices that aren't directly interpretable as error metrics, but help understand both the overall observed/estimated behavior of the gates <em>and</em> how they differ from the targets.  Although the tables on this page do not compare the estimated gates' properties directly to those of the ideal targets, many reports include an analysis of the target gates as well, which can be accessed (and compared directly to the GST estimates) through the <q>Estimates</q> dropdown menu on the sidebar.  Also, since these properties are all at least mildly gauge-dependent, it may be useful to examine different gauge-optimization choices using that dropdown menu on the sidebar.</p>

	<figure class='tbl' id="bestGatesetDecompTable">
	  <figcaption><span class="captiontitle">Decomposition of estimated gates.</span> <span class="captiondetail">This table attempts to describe each gate as a rotation operator (this interpretation is more reliable for single qubits than for other systems).   From each gate, a rotation axis and angle are extracted by considering the projection of its logarithm onto the Pauli Hamiltonian projectors.  The rotation axis and angle are (respectively) given by the direction and the magnitude (up to a conventional constant) of this projected logarithm.  In other words, the <q>rotation axis</q> is basically the Hamiltonian that generated the gate.  The angles between the various gates' rotation axes are computed from the dot products between them.</span></figcaption>
	  <script>
  $(document).ready(function() {
var switchmap_table_4707 = new Array();
switchmap_table_4707[ [0,1,0] ] = 'table_4707_1';
switchmap_table_4707[ [0,0,0] ] = 'table_4707_0';
switchmap_table_4707[ [0,2,0] ] = 'table_4707_2';
window.switchmap_table_4707 = switchmap_table_4707;

function connect_table_4707_to_switches(){
  if($('#switchbd6211_0').hasClass('initializedSwitch') && $('#switchbd6211_1').hasClass('initializedSwitch') && $('#switchbd6211_2').hasClass('initializedSwitch')) {
    $('#switchbd6211_0').on('selectmenuchange', function() {table_4707_onchange(); });
    $('#switchbd6211_1').on('selectmenuchange', function() {table_4707_onchange(); });
    $('#switchbd6211_2').on('change', function() {table_4707_onchange(); });
    $( '#table_4707' ).closest('.tabcontent').on('tabchange', function(){
table_4707_onchange(); });
    table_4707_onchange();
    console.log('Switches initialized: table_4707 handlers set');
    $( '#table_4707' ).show()
  }
  else {
    setTimeout(connect_table_4707_to_switches, 500);
    console.log('table_4707 switches NOT initialized: Waiting...');
  }
};
$(document).ready(function() {
  connect_table_4707_to_switches();
});

function table_4707_onchange() {
  var tabdiv = $( '#table_4707' ).closest('.tabcontent');
  if( tabdiv.length > 0 && !tabdiv.hasClass('active') ) return;
  var curSwitchPos = new Array();
  curSwitchPos.push($('#switchbd6211_0').val());
  curSwitchPos.push($('#switchbd6211_1').val());
  curSwitchPos.push($("#switchbd6211_2 > input[name='switchbd6211_2']:checked").val());
  var idToShow = switchmap_table_4707[ curSwitchPos ];
  $( '#table_4707' ).children().hide();
  divToShow = $( '#' + idToShow );
  if( divToShow.children().length == 0 ) {
    loadLocal('figures/' + idToShow + '.html', '#' + idToShow, function() {
        divToShow = $( '#' + idToShow );
        divToShow.show();
        divToShow.parentsUntil('#table_4707').show();
        caption = divToShow.closest('figure').children('figcaption:first');
        caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
    });
  }
  else {
    divToShow.show();
    divToShow.parentsUntil('#table_4707').show();
    caption = divToShow.closest('figure').children('figcaption:first');
    caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
  }
}
}); //end on-ready handler

</script>

<div id='table_4707' class='pygsti-wsoutput-group'>
<div class='single_switched_value' id='table_4707_0'></div>

<div class='single_switched_value' id='table_4707_1'></div>

<div class='single_switched_value' id='table_4707_2'></div>

</div>

	</figure>

	<figure id="bestGatesetChoiTable" class='tbl'>
	  <figcaption><span class="captiontitle">Estimated gates' Choi representation and spectra</span> <span class="captiondetail"> These plots show each gate's Choi-Jamiolkowski representation and that representation's eigenvalues.  Every completely positive (CP) map has a non-negative Choi spectrum, so any negative eigenvalues (shown in <span style="color:red">red</span>) indicate that the estimate violates positivity.  If a gate is perfectly unitary, its Choi spectrum will be rank-1, and real-world gates often have many Choi eigenvalues that are very close to zero.  Therefore, although negative eigenvalues indicate that the estimate is non-physical, this can easily stem from statistical fluctuations.  If statistically significant, though, it usually indicates either non-Markovianity or a failed gauge optimization.  Since the Choi matrix is Hermitian, it is displayed using colored boxes by placing the real and imaginary parts of the upper-triangle's off-diagonal elements in the upper and lower triangles of the color box plot, respectively.</span></figcaption>
	  <script>
  $(document).ready(function() {
var switchmap_table_9531 = new Array();
switchmap_table_9531[ [0,1,0] ] = 'table_9531_1';
switchmap_table_9531[ [0,0,0] ] = 'table_9531_0';
switchmap_table_9531[ [0,2,0] ] = 'table_9531_2';
window.switchmap_table_9531 = switchmap_table_9531;

function connect_table_9531_to_switches(){
  if($('#switchbd6211_0').hasClass('initializedSwitch') && $('#switchbd6211_1').hasClass('initializedSwitch') && $('#switchbd6211_2').hasClass('initializedSwitch')) {
    $('#switchbd6211_0').on('selectmenuchange', function() {table_9531_onchange(); });
    $('#switchbd6211_1').on('selectmenuchange', function() {table_9531_onchange(); });
    $('#switchbd6211_2').on('change', function() {table_9531_onchange(); });
    $( '#table_9531' ).closest('.tabcontent').on('tabchange', function(){
table_9531_onchange(); });
    table_9531_onchange();
    console.log('Switches initialized: table_9531 handlers set');
    $( '#table_9531' ).show()
  }
  else {
    setTimeout(connect_table_9531_to_switches, 500);
    console.log('table_9531 switches NOT initialized: Waiting...');
  }
};
$(document).ready(function() {
  connect_table_9531_to_switches();
});

function table_9531_onchange() {
  var tabdiv = $( '#table_9531' ).closest('.tabcontent');
  if( tabdiv.length > 0 && !tabdiv.hasClass('active') ) return;
  var curSwitchPos = new Array();
  curSwitchPos.push($('#switchbd6211_0').val());
  curSwitchPos.push($('#switchbd6211_1').val());
  curSwitchPos.push($("#switchbd6211_2 > input[name='switchbd6211_2']:checked").val());
  var idToShow = switchmap_table_9531[ curSwitchPos ];
  $( '#table_9531' ).children().hide();
  divToShow = $( '#' + idToShow );
  if( divToShow.children().length == 0 ) {
    loadLocal('figures/' + idToShow + '.html', '#' + idToShow, function() {
        divToShow = $( '#' + idToShow );
        divToShow.show();
        divToShow.parentsUntil('#table_9531').show();
        caption = divToShow.closest('figure').children('figcaption:first');
        caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
    });
  }
  else {
    divToShow.show();
    divToShow.parentsUntil('#table_9531').show();
    caption = divToShow.closest('figure').children('figcaption:first');
    caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
  }
}
}); //end on-ready handler

</script>

<div id='table_9531' class='pygsti-wsoutput-group'>
<div class='single_switched_value' id='table_9531_0'></div>

<div class='single_switched_value' id='table_9531_1'></div>

<div class='single_switched_value' id='table_9531_2'></div>

</div>

	</figure>
