	<h1>Gate Error Generators</h1>
	<p>This tab presents the <em>error generators</em> for each of the estimated gates.  Although these are not especially well-known in the literature, they are (in the pyGSTi authors' opinion) the most useful detailed diagnostic for gate errors.  The error generator <span class="math">\mathbb{L}</span> for a noisy gate <span class="math">G</span> with ideal target <span class="math">G_0</span> is defined by writing <span class="math">G = e^{\mathbb{L}} G_0</span>.  It can be thought of, more or less, as a Lindbladian superoperator that generates the error in the gate &mdash; with two caveats.  First, it is not necessarily of strict Lindblad form, because the GST-estimated gates may not be CP, and because even if they are, not every CP map is "divisible" (and nondivisible maps are not generated by Lindblad evolution).  Second, the generator reported here is a <em>post-gate</em> generator, so it answers the question "If all the noise occurred <em>after</em> the ideal gate, what Lindbladian would generate it?" This is <em>not</em> the Lindblad-type generator that would produce this noise if it acted continuously <em>during</em> the gate (i.e., simultaneously with a Hamiltonian that generates the ideal gate).  This choice is explicit; the authors of pyGSTi are concerned that reporting the continuous-time-generator would encourage a false sense of understanding the physics behind the noise, which is explicitly invalid if the gates were produced by anything other than a simple pulse.   Finally:  the error generators are very definitely gauge-dependent, so <em>caveat emptor</em> (cross-validating any inferences drawn from these generators with some sort of gauge-invariant diagnostic is highly recommended).</p>
	
	<figure id="bestGatesetErrGenTable" class='tbl'>
	  <figcaption><span class="captiontitle">Logic gate error generators</span> <span class="captiondetail"> The <b>first column</b> displays a heat map of the estimated <q>error generator</q> for each gate.  This is (more or less) the Lindbladian <span class="math">\mathbb{L}</span> that describes <em>how</em> the gate is failing to match the target.  This error generator is defined by the equation <span class="math">G = e^{\mathbb{L}} G_0</span>. If it is zero, the estimated gate matches the corresponding ideal target gate.  Note that the range of the <span style="color:red">color</span> <span style="color:blue">scale</span> is dynamically adjusted. <b>Subsequent columns</b> show the result of projecting each generator onto some subspaces of the error generator space.  Each corresponds to a different classes of well-known errors:  Hamiltonian (coherent) errors, Pauli-stochastic errors, and affine (aka non-unital) errors.  The Hamiltonian generators act by commutation with each Pauli basis element <span class="math">B_i</span>, that is <span class="math">\rho \rightarrow -i[B_i, \rho]</span>.  Stochastic generators act by conjugation with each basis element, <span class="math">\rho \rightarrow B_i \rho B_i^\dagger</span>.  Affine generators act by projecting everything onto a particular basis element, <span class="math">\rho \rightarrow \mathrm{Tr}(\rho) B_i</span>.  Roughly speaking, the Hamiltonian projection corresponds precisely to the Hamiltonian that would produce the coherent part of the error, while the Pauli-stochastic generators correspond to the rates of all the Pauli errors (e.g., X errors, Z errors, their 2-qubit counterparts, or whatever is appropriate for the system being analyzed).</span></figcaption>
	  <script>
  $(document).ready(function() {
var switchmap_table_9749 = new Array();
switchmap_table_9749[ [0,1,0] ] = 'table_9749_1';
switchmap_table_9749[ [0,0,0] ] = 'table_9749_0';
switchmap_table_9749[ [0,2,0] ] = 'table_9749_2';
window.switchmap_table_9749 = switchmap_table_9749;

function connect_table_9749_to_switches(){
  if($('#switchbd6211_0').hasClass('initializedSwitch') && $('#switchbd6211_1').hasClass('initializedSwitch') && $('#switchbd6211_2').hasClass('initializedSwitch')) {
    $('#switchbd6211_0').on('selectmenuchange', function() {table_9749_onchange(); });
    $('#switchbd6211_1').on('selectmenuchange', function() {table_9749_onchange(); });
    $('#switchbd6211_2').on('change', function() {table_9749_onchange(); });
    $( '#table_9749' ).closest('.tabcontent').on('tabchange', function(){
table_9749_onchange(); });
    table_9749_onchange();
    console.log('Switches initialized: table_9749 handlers set');
    $( '#table_9749' ).show()
  }
  else {
    setTimeout(connect_table_9749_to_switches, 500);
    console.log('table_9749 switches NOT initialized: Waiting...');
  }
};
$(document).ready(function() {
  connect_table_9749_to_switches();
});

function table_9749_onchange() {
  var tabdiv = $( '#table_9749' ).closest('.tabcontent');
  if( tabdiv.length > 0 && !tabdiv.hasClass('active') ) return;
  var curSwitchPos = new Array();
  curSwitchPos.push($('#switchbd6211_0').val());
  curSwitchPos.push($('#switchbd6211_1').val());
  curSwitchPos.push($("#switchbd6211_2 > input[name='switchbd6211_2']:checked").val());
  var idToShow = switchmap_table_9749[ curSwitchPos ];
  $( '#table_9749' ).children().hide();
  divToShow = $( '#' + idToShow );
  if( divToShow.children().length == 0 ) {
    loadLocal('figures/' + idToShow + '.html', '#' + idToShow, function() {
        divToShow = $( '#' + idToShow );
        divToShow.show();
        divToShow.parentsUntil('#table_9749').show();
        caption = divToShow.closest('figure').children('figcaption:first');
        caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
    });
  }
  else {
    divToShow.show();
    divToShow.parentsUntil('#table_9749').show();
    caption = divToShow.closest('figure').children('figcaption:first');
    caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
  }
}
}); //end on-ready handler

</script>

<div id='table_9749' class='pygsti-wsoutput-group'>
<div class='single_switched_value' id='table_9749_0'></div>

<div class='single_switched_value' id='table_9749_1'></div>

<div class='single_switched_value' id='table_9749_2'></div>

</div>

	</figure>
