        <h1>Gauge Invariant Error Metrics applied to germ sequences</h1>
	<p> All of the per-gate gauge-invariant metrics of the previous tab are functions of each gate's spectrum and do not account for how the gate relates to other gates.  In an attempt to extract some of that information in a gauge-invariant way, this tab looks at the spectra of the germ-sequences.  Each germ amplifies (i.e. has eigenvalues which correspond to) certain directions in <q>gate-set space</q>.  Some of these directions describe how the single gates relate to one another, and, if an amplificationally complete set of germs was used, <em>every direction is amplified by at least one germ</em>.  This implies that the (gauge-invariant) spectra of the germs should constitute a full description of the gate set.  This tab compares each germ-spectrum to the spectrum of that germ if it were generated using the set <q>eigenspace-projected</q> gates obtained by placing each gate&#39;s GST-estimated eigenvalues within eigenbasis of the ideal target gate.</p>
	
	<figure id="bestGatesVsTargetTable_gigerms" class='tbl'>
	  <figcaption><span class="captiontitle">Discrepancy between germs and spectral gates</span> <span class="captiondetail"> This table requires some explaining.  It tries to answer the following question:  "Is it plausible that each gate has <em>only</em> spectral errors, so that its eigenvectors are exactly correct?".  GST can more or less directly estimate each gate's spectrum, because that's gauge-invariant.  But gate eigen<em>bases</em> are relational to other gates and gauge-variant.  To infer them, GST basically does precise spectrum estimation on <em>germs</em> that incorporate multiple gates.  Each germ's estimated spectrum is shown elsewhere.  <em>This</em> table compares each germ's estimated spectrum to the spectrum it <em>would</em> have if each individual gate had the eigenvalues that GST estimated for it, but exactly the right (target) eigenbasis.  This is the "eigenspace-projected" estimate of that gate.  Comparing the estimated germ spectra with those predicted by the eigenspace-projected gates yields gauge-invariant metrics of how much of the overall error can be attributed to purely spectral errors in each gate.  If the estimated-gate eigenvalues account for everything, all of the discrepancy values in this table would equal zero.</span></figcaption>
	  <script>
  $(document).ready(function() {
var switchmap_table_1734 = new Array();
switchmap_table_1734[ [0,1] ] = 'table_1734_1';
switchmap_table_1734[ [0,0] ] = 'table_1734_0';
window.switchmap_table_1734 = switchmap_table_1734;

function connect_table_1734_to_switches(){
  if($('#switchbd1410_0').hasClass('initializedSwitch') && $('#switchbd1410_1').hasClass('initializedSwitch')) {
    $('#switchbd1410_0').on('selectmenuchange', function() {table_1734_onchange(); });
    $('#switchbd1410_1').on('selectmenuchange', function() {table_1734_onchange(); });
    $( '#table_1734' ).closest('.tabcontent').on('tabchange', function(){
table_1734_onchange(); });
    table_1734_onchange();
    console.log('Switches initialized: table_1734 handlers set');
    $( '#table_1734' ).show()
  }
  else {
    setTimeout(connect_table_1734_to_switches, 500);
    console.log('table_1734 switches NOT initialized: Waiting...');
  }
};
$(document).ready(function() {
  connect_table_1734_to_switches();
});

function table_1734_onchange() {
  var tabdiv = $( '#table_1734' ).closest('.tabcontent');
  if( tabdiv.length > 0 && !tabdiv.hasClass('active') ) return;
  var curSwitchPos = new Array();
  curSwitchPos.push($('#switchbd1410_0').val());
  curSwitchPos.push($('#switchbd1410_1').val());
  var idToShow = switchmap_table_1734[ curSwitchPos ];
  $( '#table_1734' ).children().hide();
  divToShow = $( '#' + idToShow );
  if( divToShow.children().length == 0 ) {
    loadLocal('figures/' + idToShow + '.html', '#' + idToShow, function() {
        divToShow = $( '#' + idToShow );
        divToShow.show();
        divToShow.parentsUntil('#table_1734').show();
        caption = divToShow.closest('figure').children('figcaption:first');
        caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
    });
  }
  else {
    divToShow.show();
    divToShow.parentsUntil('#table_1734').show();
    caption = divToShow.closest('figure').children('figcaption:first');
    caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
  }
}
}); //end on-ready handler

</script>

<div id='table_1734' class='pygsti-wsoutput-group'>
<div class='single_switched_value' id='table_1734_0'></div>

<div class='single_switched_value' id='table_1734_1'></div>

</div>

	</figure>

	<figure id="bestGermsEigenvalueTable" class='tbl'>
	  <figcaption><span class="captiontitle">Eigenvalues of estimated germs.</span> <span class="captiondetail">GST directly estimates each gate's spectrum (it's gauge-invariant), But the gates' eigen<em>bases</em> are relational to other gates and gauge-variant.  GST infers them from the spectra of <em>germs</em> that incorporate multiple gates.  Each germ's spectrum is gauge-invariant and directly estimatable, and this table lists them.  It also lists metrics that compare these spectra to the ones predicted by the <q>eigenspace-projected</q> gates (see elsewhere on this tab).  If the individual gates' eigenvalues account for all imperfections, then the estimated and predicted germ spectra should be equal.  Since spectra aren't ordered, the eigenvalues need to be matched up or aligned somehow.  PyGSTi does this by identifying a minimum-weight matching based on the metric being computed.  Mathematical descriptions of the metrics appear when hovering over the column headers.</span></figcaption>
	  <script>
  $(document).ready(function() {
var switchmap_table_6109 = new Array();
switchmap_table_6109[ [0,1] ] = 'table_6109_1';
switchmap_table_6109[ [0,0] ] = 'table_6109_0';
window.switchmap_table_6109 = switchmap_table_6109;

function connect_table_6109_to_switches(){
  if($('#switchbd1410_0').hasClass('initializedSwitch') && $('#switchbd1410_1').hasClass('initializedSwitch')) {
    $('#switchbd1410_0').on('selectmenuchange', function() {table_6109_onchange(); });
    $('#switchbd1410_1').on('selectmenuchange', function() {table_6109_onchange(); });
    $( '#table_6109' ).closest('.tabcontent').on('tabchange', function(){
table_6109_onchange(); });
    table_6109_onchange();
    console.log('Switches initialized: table_6109 handlers set');
    $( '#table_6109' ).show()
  }
  else {
    setTimeout(connect_table_6109_to_switches, 500);
    console.log('table_6109 switches NOT initialized: Waiting...');
  }
};
$(document).ready(function() {
  connect_table_6109_to_switches();
});

function table_6109_onchange() {
  var tabdiv = $( '#table_6109' ).closest('.tabcontent');
  if( tabdiv.length > 0 && !tabdiv.hasClass('active') ) return;
  var curSwitchPos = new Array();
  curSwitchPos.push($('#switchbd1410_0').val());
  curSwitchPos.push($('#switchbd1410_1').val());
  var idToShow = switchmap_table_6109[ curSwitchPos ];
  $( '#table_6109' ).children().hide();
  divToShow = $( '#' + idToShow );
  if( divToShow.children().length == 0 ) {
    loadLocal('figures/' + idToShow + '.html', '#' + idToShow, function() {
        divToShow = $( '#' + idToShow );
        divToShow.show();
        divToShow.parentsUntil('#table_6109').show();
        caption = divToShow.closest('figure').children('figcaption:first');
        caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
    });
  }
  else {
    divToShow.show();
    divToShow.parentsUntil('#table_6109').show();
    caption = divToShow.closest('figure').children('figcaption:first');
    caption.css('width', Math.round(divToShow.width()*0.9) + 'px');
  }
}
}); //end on-ready handler

</script>

<div id='table_6109' class='pygsti-wsoutput-group'>
<div class='single_switched_value' id='table_6109_0'></div>

<div class='single_switched_value' id='table_6109_1'></div>

</div>

	</figure>

